// Code generated by generator. DO NOT EDIT.

package cluster

import (
	"context"
	"fmt"

	configv1alpha1 "github.com/loft-sh/agentapi/pkg/apis/kiosk/config/v1alpha1"
	storagev1 "github.com/loft-sh/agentapi/pkg/apis/loft/storage/v1"
	"github.com/loft-sh/apiserver/pkg/builders"
	"k8s.io/apimachinery/pkg/apis/meta/internalversion"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apiserver/pkg/registry/generic"
	"k8s.io/apiserver/pkg/registry/rest"
	configrest "k8s.io/client-go/rest"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type NewRESTFunc func(config *configrest.Config, cachedClient client.Client, uncachedClient client.Client) rest.Storage

var (
	ClusterAccountStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalAccount,
		func() runtime.Object { return &Account{} },     // Register versioned resource
		func() runtime.Object { return &AccountList{} }, // Register versioned resource list
		NewAccountREST,
	)
	NewAccountREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAccountRESTFunc(Config, CachedClient, UncachedClient)
	}
	NewAccountRESTFunc        NewRESTFunc
	ClusterHelmReleaseStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalHelmRelease,
		func() runtime.Object { return &HelmRelease{} },     // Register versioned resource
		func() runtime.Object { return &HelmReleaseList{} }, // Register versioned resource list
		NewHelmReleaseREST,
	)
	NewHelmReleaseREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewHelmReleaseRESTFunc(Config, CachedClient, UncachedClient)
	}
	NewHelmReleaseRESTFunc        NewRESTFunc
	ClusterSleepModeConfigStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalSleepModeConfig,
		func() runtime.Object { return &SleepModeConfig{} },     // Register versioned resource
		func() runtime.Object { return &SleepModeConfigList{} }, // Register versioned resource list
		NewSleepModeConfigREST,
	)
	NewSleepModeConfigREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewSleepModeConfigRESTFunc(Config, CachedClient, UncachedClient)
	}
	NewSleepModeConfigRESTFunc   NewRESTFunc
	ClusterVirtualClusterStorage = builders.NewApiResourceWithStorage( // Resource status endpoint
		InternalVirtualCluster,
		func() runtime.Object { return &VirtualCluster{} },     // Register versioned resource
		func() runtime.Object { return &VirtualClusterList{} }, // Register versioned resource list
		NewVirtualClusterREST,
	)
	NewVirtualClusterREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewVirtualClusterRESTFunc(Config, CachedClient, UncachedClient)
	}
	NewVirtualClusterRESTFunc NewRESTFunc
	InternalAccount           = builders.NewInternalResource(
		"accounts",
		"Account",
		func() runtime.Object { return &Account{} },
		func() runtime.Object { return &AccountList{} },
	)
	InternalAccountStatus = builders.NewInternalResourceStatus(
		"accounts",
		"AccountStatus",
		func() runtime.Object { return &Account{} },
		func() runtime.Object { return &AccountList{} },
	)
	InternalAccountClusterRolesREST = builders.NewInternalSubresource(
		"accounts", "AccountClusterRoles", "clusterroles",
		func() runtime.Object { return &AccountClusterRoles{} },
	)
	NewAccountClusterRolesREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewAccountClusterRolesRESTFunc(Config, CachedClient, UncachedClient)
	}
	NewAccountClusterRolesRESTFunc NewRESTFunc
	InternalHelmRelease            = builders.NewInternalResource(
		"helmreleases",
		"HelmRelease",
		func() runtime.Object { return &HelmRelease{} },
		func() runtime.Object { return &HelmReleaseList{} },
	)
	InternalHelmReleaseStatus = builders.NewInternalResourceStatus(
		"helmreleases",
		"HelmReleaseStatus",
		func() runtime.Object { return &HelmRelease{} },
		func() runtime.Object { return &HelmReleaseList{} },
	)
	InternalHelmReleaseRollbackREST = builders.NewInternalSubresource(
		"helmreleases", "HelmReleaseRollback", "rollback",
		func() runtime.Object { return &HelmReleaseRollback{} },
	)
	NewHelmReleaseRollbackREST = func(getter generic.RESTOptionsGetter) rest.Storage {
		return NewHelmReleaseRollbackRESTFunc(Config, CachedClient, UncachedClient)
	}
	NewHelmReleaseRollbackRESTFunc NewRESTFunc
	InternalSleepModeConfig        = builders.NewInternalResource(
		"sleepmodeconfigs",
		"SleepModeConfig",
		func() runtime.Object { return &SleepModeConfig{} },
		func() runtime.Object { return &SleepModeConfigList{} },
	)
	InternalSleepModeConfigStatus = builders.NewInternalResourceStatus(
		"sleepmodeconfigs",
		"SleepModeConfigStatus",
		func() runtime.Object { return &SleepModeConfig{} },
		func() runtime.Object { return &SleepModeConfigList{} },
	)
	InternalVirtualCluster = builders.NewInternalResource(
		"virtualclusters",
		"VirtualCluster",
		func() runtime.Object { return &VirtualCluster{} },
		func() runtime.Object { return &VirtualClusterList{} },
	)
	InternalVirtualClusterStatus = builders.NewInternalResourceStatus(
		"virtualclusters",
		"VirtualClusterStatus",
		func() runtime.Object { return &VirtualCluster{} },
		func() runtime.Object { return &VirtualClusterList{} },
	)
	// Registered resources and subresources
	ApiVersion = builders.NewApiGroup("cluster.loft.sh").WithKinds(
		InternalAccount,
		InternalAccountStatus,
		InternalAccountClusterRolesREST,
		InternalHelmRelease,
		InternalHelmReleaseStatus,
		InternalHelmReleaseRollbackREST,
		InternalSleepModeConfig,
		InternalSleepModeConfigStatus,
		InternalVirtualCluster,
		InternalVirtualClusterStatus,
	)

	// Required by code generated by go2idl
	AddToScheme = (&runtime.SchemeBuilder{
		ApiVersion.SchemeBuilder.AddToScheme,
		RegisterDefaults,
	}).AddToScheme
	SchemeBuilder      = ApiVersion.SchemeBuilder
	localSchemeBuilder = &SchemeBuilder
	SchemeGroupVersion = ApiVersion.GroupVersion
)

// Required by code generated by go2idl
// Kind takes an unqualified kind and returns a Group qualified GroupKind
func Kind(kind string) schema.GroupKind {
	return SchemeGroupVersion.WithKind(kind).GroupKind()
}

// Required by code generated by go2idl
// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource {
	return SchemeGroupVersion.WithResource(resource).GroupResource()
}

type Status string

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type Account struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   AccountSpec
	Status AccountStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AccountClusterRoles struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	ClusterRoles []string
}

type AccountSpec struct {
	configv1alpha1.AccountSpec
}

type AccountStatus struct {
	configv1alpha1.AccountStatus
}

type Chart struct {
	Name     string
	Version  string
	RepoURL  string
	Username string
	Password string
}

type EpochInfo struct {
	Start int64
	Slept int64
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type HelmRelease struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   HelmReleaseSpec
	Status HelmReleaseStatus
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type HelmReleaseRollback struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Revision string
}

type HelmReleaseSpec struct {
	Chart                 Chart
	Manifests             string
	Config                string
	InsecureSkipTlsVerify bool
}

type HelmReleaseStatus struct {
	Revision int
	Info     *Info
	Metadata *Metadata
}

type Info struct {
	FirstDeployed metav1.Time
	LastDeployed  metav1.Time
	Deleted       metav1.Time
	Description   string
	Status        Status
	Notes         string
}

type Maintainer struct {
	Name  string
	Email string
	URL   string
}

type Metadata struct {
	Name        string
	Home        string
	Sources     []string
	Version     string
	Description string
	Keywords    []string
	Maintainers []*Maintainer
	Icon        string
	APIVersion  string
	Condition   string
	Tags        string
	AppVersion  string
	Deprecated  bool
	Annotations map[string]string
	KubeVersion string
	Type        string
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SleepModeConfig struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   SleepModeConfigSpec
	Status SleepModeConfigStatus
}

type SleepModeConfigSpec struct {
	ForceSleep         bool
	ForceSleepDuration *int64
	DeleteAllPods      bool
	DeleteAfter        int64
	SleepAfter         int64
}

type SleepModeConfigStatus struct {
	LastActivity        int64
	SleepingSince       int64
	ActiveConnections   int64
	CurrentEpoch        *EpochInfo
	LastEpoch           *EpochInfo
	SleptLastThirtyDays *float64
	SleptLastSevenDays  *float64
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualCluster struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   VirtualClusterSpec
	Status VirtualClusterStatus
}

type VirtualClusterSpec struct {
	storagev1.VirtualClusterSpec
}

type VirtualClusterStatus struct {
	storagev1.VirtualClusterStatus
}

//
// Account Functions and Structs
//
// +k8s:deepcopy-gen=false
type AccountStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type AccountStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AccountList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []Account
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type AccountClusterRolesList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []AccountClusterRoles
}

func (Account) NewStatus() interface{} {
	return AccountStatus{}
}

func (pc *Account) GetStatus() interface{} {
	return pc.Status
}

func (pc *Account) SetStatus(s interface{}) {
	pc.Status = s.(AccountStatus)
}

func (pc *Account) GetSpec() interface{} {
	return pc.Spec
}

func (pc *Account) SetSpec(s interface{}) {
	pc.Spec = s.(AccountSpec)
}

func (pc *Account) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *Account) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc Account) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store Account.
// +k8s:deepcopy-gen=false
type AccountRegistry interface {
	ListAccounts(ctx context.Context, options *internalversion.ListOptions) (*AccountList, error)
	GetAccount(ctx context.Context, id string, options *metav1.GetOptions) (*Account, error)
	CreateAccount(ctx context.Context, id *Account) (*Account, error)
	UpdateAccount(ctx context.Context, id *Account) (*Account, error)
	DeleteAccount(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewAccountRegistry(sp builders.StandardStorageProvider) AccountRegistry {
	return &storageAccount{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageAccount struct {
	builders.StandardStorageProvider
}

func (s *storageAccount) ListAccounts(ctx context.Context, options *internalversion.ListOptions) (*AccountList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*AccountList), err
}

func (s *storageAccount) GetAccount(ctx context.Context, id string, options *metav1.GetOptions) (*Account, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*Account), nil
}

func (s *storageAccount) CreateAccount(ctx context.Context, object *Account) (*Account, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Account), nil
}

func (s *storageAccount) UpdateAccount(ctx context.Context, object *Account) (*Account, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*Account), nil
}

func (s *storageAccount) DeleteAccount(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// HelmRelease Functions and Structs
//
// +k8s:deepcopy-gen=false
type HelmReleaseStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type HelmReleaseStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type HelmReleaseList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []HelmRelease
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type HelmReleaseRollbackList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []HelmReleaseRollback
}

func (HelmRelease) NewStatus() interface{} {
	return HelmReleaseStatus{}
}

func (pc *HelmRelease) GetStatus() interface{} {
	return pc.Status
}

func (pc *HelmRelease) SetStatus(s interface{}) {
	pc.Status = s.(HelmReleaseStatus)
}

func (pc *HelmRelease) GetSpec() interface{} {
	return pc.Spec
}

func (pc *HelmRelease) SetSpec(s interface{}) {
	pc.Spec = s.(HelmReleaseSpec)
}

func (pc *HelmRelease) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *HelmRelease) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc HelmRelease) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store HelmRelease.
// +k8s:deepcopy-gen=false
type HelmReleaseRegistry interface {
	ListHelmReleases(ctx context.Context, options *internalversion.ListOptions) (*HelmReleaseList, error)
	GetHelmRelease(ctx context.Context, id string, options *metav1.GetOptions) (*HelmRelease, error)
	CreateHelmRelease(ctx context.Context, id *HelmRelease) (*HelmRelease, error)
	UpdateHelmRelease(ctx context.Context, id *HelmRelease) (*HelmRelease, error)
	DeleteHelmRelease(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewHelmReleaseRegistry(sp builders.StandardStorageProvider) HelmReleaseRegistry {
	return &storageHelmRelease{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageHelmRelease struct {
	builders.StandardStorageProvider
}

func (s *storageHelmRelease) ListHelmReleases(ctx context.Context, options *internalversion.ListOptions) (*HelmReleaseList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*HelmReleaseList), err
}

func (s *storageHelmRelease) GetHelmRelease(ctx context.Context, id string, options *metav1.GetOptions) (*HelmRelease, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*HelmRelease), nil
}

func (s *storageHelmRelease) CreateHelmRelease(ctx context.Context, object *HelmRelease) (*HelmRelease, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*HelmRelease), nil
}

func (s *storageHelmRelease) UpdateHelmRelease(ctx context.Context, object *HelmRelease) (*HelmRelease, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*HelmRelease), nil
}

func (s *storageHelmRelease) DeleteHelmRelease(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// SleepModeConfig Functions and Structs
//
// +k8s:deepcopy-gen=false
type SleepModeConfigStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type SleepModeConfigStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type SleepModeConfigList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []SleepModeConfig
}

func (SleepModeConfig) NewStatus() interface{} {
	return SleepModeConfigStatus{}
}

func (pc *SleepModeConfig) GetStatus() interface{} {
	return pc.Status
}

func (pc *SleepModeConfig) SetStatus(s interface{}) {
	pc.Status = s.(SleepModeConfigStatus)
}

func (pc *SleepModeConfig) GetSpec() interface{} {
	return pc.Spec
}

func (pc *SleepModeConfig) SetSpec(s interface{}) {
	pc.Spec = s.(SleepModeConfigSpec)
}

func (pc *SleepModeConfig) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *SleepModeConfig) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc SleepModeConfig) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store SleepModeConfig.
// +k8s:deepcopy-gen=false
type SleepModeConfigRegistry interface {
	ListSleepModeConfigs(ctx context.Context, options *internalversion.ListOptions) (*SleepModeConfigList, error)
	GetSleepModeConfig(ctx context.Context, id string, options *metav1.GetOptions) (*SleepModeConfig, error)
	CreateSleepModeConfig(ctx context.Context, id *SleepModeConfig) (*SleepModeConfig, error)
	UpdateSleepModeConfig(ctx context.Context, id *SleepModeConfig) (*SleepModeConfig, error)
	DeleteSleepModeConfig(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewSleepModeConfigRegistry(sp builders.StandardStorageProvider) SleepModeConfigRegistry {
	return &storageSleepModeConfig{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageSleepModeConfig struct {
	builders.StandardStorageProvider
}

func (s *storageSleepModeConfig) ListSleepModeConfigs(ctx context.Context, options *internalversion.ListOptions) (*SleepModeConfigList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SleepModeConfigList), err
}

func (s *storageSleepModeConfig) GetSleepModeConfig(ctx context.Context, id string, options *metav1.GetOptions) (*SleepModeConfig, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*SleepModeConfig), nil
}

func (s *storageSleepModeConfig) CreateSleepModeConfig(ctx context.Context, object *SleepModeConfig) (*SleepModeConfig, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SleepModeConfig), nil
}

func (s *storageSleepModeConfig) UpdateSleepModeConfig(ctx context.Context, object *SleepModeConfig) (*SleepModeConfig, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*SleepModeConfig), nil
}

func (s *storageSleepModeConfig) DeleteSleepModeConfig(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}

//
// VirtualCluster Functions and Structs
//
// +k8s:deepcopy-gen=false
type VirtualClusterStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type VirtualClusterStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type VirtualClusterList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []VirtualCluster
}

func (VirtualCluster) NewStatus() interface{} {
	return VirtualClusterStatus{}
}

func (pc *VirtualCluster) GetStatus() interface{} {
	return pc.Status
}

func (pc *VirtualCluster) SetStatus(s interface{}) {
	pc.Status = s.(VirtualClusterStatus)
}

func (pc *VirtualCluster) GetSpec() interface{} {
	return pc.Spec
}

func (pc *VirtualCluster) SetSpec(s interface{}) {
	pc.Spec = s.(VirtualClusterSpec)
}

func (pc *VirtualCluster) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *VirtualCluster) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc VirtualCluster) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store VirtualCluster.
// +k8s:deepcopy-gen=false
type VirtualClusterRegistry interface {
	ListVirtualClusters(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterList, error)
	GetVirtualCluster(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualCluster, error)
	CreateVirtualCluster(ctx context.Context, id *VirtualCluster) (*VirtualCluster, error)
	UpdateVirtualCluster(ctx context.Context, id *VirtualCluster) (*VirtualCluster, error)
	DeleteVirtualCluster(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewVirtualClusterRegistry(sp builders.StandardStorageProvider) VirtualClusterRegistry {
	return &storageVirtualCluster{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageVirtualCluster struct {
	builders.StandardStorageProvider
}

func (s *storageVirtualCluster) ListVirtualClusters(ctx context.Context, options *internalversion.ListOptions) (*VirtualClusterList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualClusterList), err
}

func (s *storageVirtualCluster) GetVirtualCluster(ctx context.Context, id string, options *metav1.GetOptions) (*VirtualCluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualCluster), nil
}

func (s *storageVirtualCluster) CreateVirtualCluster(ctx context.Context, object *VirtualCluster) (*VirtualCluster, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualCluster), nil
}

func (s *storageVirtualCluster) UpdateVirtualCluster(ctx context.Context, object *VirtualCluster) (*VirtualCluster, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*VirtualCluster), nil
}

func (s *storageVirtualCluster) DeleteVirtualCluster(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, nil, &metav1.DeleteOptions{})
	return sync, err
}
